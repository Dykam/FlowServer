using System;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using Flow.Properties;

namespace Flow
{
    /// <remarks>
    ///     Contains the info about the incoming request.
    /// </remarks>
    public class RequestInfo : IDisposable, IDumpable<RequestInfo.RequestInfoDump>
    {
        protected const string DefaultHtppVersion = "HTTP/1.1";

        protected static readonly Regex FirstLineParser =
            new Regex("^(?<Method>[A-Za-z]+) (?<Path>.*) (?<Version>[^ ]+)$", RegexOptions.Compiled);

        private static readonly char[] Seperator = {':'};
        protected ReadOnlyNetworkStream BodyInternal;
        protected bool Disposed;
        protected SmartDictionary<string, string> HeadersInternal;
        protected string HttpVersion;

        private RequestMethods _method;
        protected TextReader Reader;
        protected HeaderBuilder Response;

        protected NetworkStream Stream;

        internal RequestInfo(Router router, TcpClient newClient, int port, Func<int, string> statusMessageFetcher,
            string httpVersion)
        {
            GetStatusMessage = statusMessageFetcher;
            HttpVersion = httpVersion;
            @Router = router;
            BodyInternal = new ReadOnlyNetworkStream(newClient.GetStream());

            Client = newClient;
            Stream = Client.GetStream();
            Reader = new StreamReader(Stream);
            Port = port;

            HeadersInternal = new SmartDictionary<string, string>();

            Headers = new ReadOnlySmartDictionary<string, string>(HeadersInternal);

            FetchRequestLine();

            if (!FetchHeaders())
            {
                throw new Exception("Error during fetching of the headers.");
            }
        }

        internal RequestInfo(Router router, TcpClient newClient, int port, Func<int, string> statusMessageFetcher)
            : this(router, newClient, port, statusMessageFetcher, DefaultHtppVersion)
        {
        }

        internal RequestInfo(Router router, TcpClient newClient, int port, string httpVersion)
            : this(
                router, newClient, port, status => (string) Settings.Default["Status" + status.ToString()], httpVersion)
        {
        }

        internal RequestInfo(Router router, TcpClient newClient, int port)
            : this(router, newClient, port, DefaultHtppVersion)
        {
        }

        /// <value>
        ///     The RequestMethod of the incoming request.
        /// </value>
        public RequestMethods Method => _method;

        /// <value>
        ///     The requested resource.
        /// </value>
        public string Path { get; private set; }

        /// <value>
        ///     The http version the requesting client uses.
        /// </value>
        public string Version { get; private set; }

        /// <value>
        ///     The Headers of the request.
        /// </value>
        public ReadOnlySmartDictionary<string, string> Headers { get; private set; }

        /// <value>
        ///     The port on which the client requested.
        /// </value>
        public int Port { get; private set; }

        /// <value>
        ///     The <see cref="TcpClient" /> generated by the router.
        /// </value>
        public TcpClient Client { get; }

        /// <value>
        ///     The router which routered this request.
        /// </value>
        public Router @Router { get; private set; }

        /// <value>
        ///     The default http status code message fetcher.
        /// </value>
        public static Func<int, string> GetStatusMessage { get; set; }

        /// <summary>
        ///     Disposes the request and the underlying streams.
        /// </summary>
        public void Dispose()
        {
            if (Disposed) return;

            Stream?.Dispose();
            Client?.Close();
            Response?.Dispose();
            Disposed = true;
        }

        RequestInfoDump IDumpable<RequestInfoDump>.Dump()
        {
            return new RequestInfoDump(this);
        }

        private bool FetchHeaders()
        {
            var previous = "";
            while (true)
            {
                var line = Reader.ReadLine();
                if (string.IsNullOrEmpty(line) || line == "\n")
                    return AddLine(previous);
                if (line.StartsWith(" ") || line.StartsWith("\t"))
                    previous += line.Trim();
                else
                {
                    AddLine(previous);
                    previous = line;
                }
            }
        }

        private bool AddLine(string line)
        {
            if (string.IsNullOrEmpty(line))
                return false;

            var parts = line.Split(Seperator, 2);
            if (parts.Length != 2)
                return false;

            HeadersInternal[parts[0].Trim()] = parts[1].Trim();
            return true;
        }

        private void FetchRequestLine()
        {
            string firstLine;
            do
            {
                firstLine = Reader.ReadLine();
                if (string.IsNullOrEmpty(firstLine))
                    throw new Exception("Error during fetching of the request line.");
            } while (firstLine == "\n" || firstLine == "\r\n" || firstLine == "\r");

            if (string.IsNullOrEmpty(firstLine)) return;

            var firstLineMatch = FirstLineParser.Match(firstLine);
            var method = firstLineMatch.Groups["Method"].ToString();
            if (!EnumTryParse(method, out _method))
            {
                _method = RequestMethods.None;
            }
            Path = firstLineMatch.Groups["Path"].ToString();
            Path = Uri.UnescapeDataString(Path);
            Version = firstLineMatch.Groups["Version"].ToString();
        }

        private static bool EnumTryParse<T>(string strType, out T result)
        {
            var strTypeFixed = strType.Replace(' ', '_');
            if (Enum.IsDefined(typeof (T), strTypeFixed))
            {
                result = (T) Enum.Parse(typeof (T), strTypeFixed, true);
                return true;
            }
            foreach (var value in Enum.GetNames(typeof (T)).Where(value => value.Equals(strTypeFixed, StringComparison.OrdinalIgnoreCase)))
            {
                result = (T) Enum.Parse(typeof (T), value);
                return true;
            }
            result = default(T);
            return false;
        }

        public class RequestInfoDump
        {
            public RequestInfoDump(RequestInfo info)
            {
                RequestInfo = info;
            }

            public RequestInfo RequestInfo { get; }

            public NetworkStream Stream => RequestInfo.Stream;

            public TextReader Reader => RequestInfo.Reader;

            public bool Disposed => RequestInfo.Disposed;

            public string HttpVersion => RequestInfo.HttpVersion;

            public HeaderBuilder Response => RequestInfo.Response;

            public SmartDictionary<string, string> Headers => RequestInfo.HeadersInternal;
        }
    }
}