/*   Copyright 2009 Dykam (kramieb@gmail.com)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net.Sockets;
using System.IO;
using System.Text.RegularExpressions;
using Flow.Handlers;

namespace Flow
{
	/// <remarks>
	/// Contains the info about the incoming request.
	/// </remarks>
	public class RequestInfo : IDisposable, IDumpable<RequestInfo.RequestInfoDump>
	{
		protected const string defaultHtppVersion = "HTTP/1.1";

		protected NetworkStream stream;
		protected ReadOnlyNetworkStream body;
		protected TextReader reader;
		protected bool disposed;
		protected String httpVersion;
		protected HeaderBuilder response;
		protected SmartDictionary<string, string> headers;

		protected static readonly Regex firstLineParser = new Regex("^(?<Method>[A-Za-z]+) (?<Path>.*) (?<Version>[^ ]+)$", RegexOptions.Compiled);

		RequestMethods method;
		/// <value>
		/// The RequestMethod of the incoming request.
		/// </value>
		public RequestMethods Method { get { return method; } }
		/// <value>
		/// The requested resource.
		/// </value>
		public string Path { get; private set; }
		/// <value>
		/// The http version the requesting client uses.
		/// </value>
		public string Version { get; private set; }
		/// <value>
		/// The Headers of the request.
		/// </value>
		public ReadOnlySmartDictionary<String, String> Headers { get; private set; }

		/// <value>
		/// The port on which the client requested.
		/// </value>
		public int Port { get; private set; }
		/// <value>
		/// The <see cref="TcpClient"/> generated by the router.
		/// </value>
		public TcpClient Client { get; private set; }
		/// <value>
		/// The router which routered this request.
		/// </value>
		public Router @Router { get; private set; }

		/// <value>
		/// The default http status code message fetcher.
		/// </value>
		public static Func<int, string> GetStatusMessage { get; set; }

		internal RequestInfo(Router router, TcpClient newClient, int port, Func<int, string> statusMessageFetcher, string httpVersion)
		{
			GetStatusMessage = statusMessageFetcher;
			this.httpVersion = httpVersion;
			@Router = router;
			body = new ReadOnlyNetworkStream(newClient.GetStream());

			Client = newClient;
			stream = Client.GetStream();
			reader = (TextReader)new StreamReader(stream);
			Port = port;

			headers = new SmartDictionary<string, string>();

			Headers = new ReadOnlySmartDictionary<string, string>(headers);

			fetchRequestLine();

			if (!fetchHeaders()) {
				throw new Exception("Error during fetching of the headers.");
			}
		}
		internal RequestInfo(Router router, TcpClient newClient, int port, Func<int, string> statusMessageFetcher)
			: this(router, newClient, port, statusMessageFetcher, defaultHtppVersion)
		{
		}
		internal RequestInfo(Router router, TcpClient newClient, int port, string httpVersion)
			: this(router, newClient, port, status => (String)Properties.Settings.Default["Status" + status.ToString()], httpVersion)
		{
		}
		internal RequestInfo(Router router, TcpClient newClient, int port)
			: this(router, newClient, port, defaultHtppVersion)
		{
		}

		bool fetchHeaders()
		{
			string line = string.Empty;
			string previous = string.Empty;
			while (true) {
				line = reader.ReadLine();
				if (string.IsNullOrEmpty(line) || line == "\n")
					return addLine(previous);
				else if (line.StartsWith(" ") || line.StartsWith("\t"))
					previous += line.Trim();
				else {
					addLine(previous);
					previous = line;
				}
			}
		}

		static readonly char[] seperator = new[] { ':' };

		bool addLine(string line)
		{
			if (string.IsNullOrEmpty(line))
				return false;

			var parts = line.Split(seperator, 2);
			if (parts.Length != 2)
				return false;

			headers[parts[0].Trim()] = parts[1].Trim();
			return true;
		}

		void fetchRequestLine()
		{
			string firstLine;
			do {
				firstLine = reader.ReadLine();
				if (string.IsNullOrEmpty(firstLine))
					throw new Exception("Error during fetching of the request line.");
			} while (firstLine == "\n" || firstLine == "\r\n" || firstLine == "\r");
			if (!string.IsNullOrEmpty(firstLine)) {
				var firstLineMatch = firstLineParser.Match(firstLine);
				var method = firstLineMatch.Groups["Method"].ToString();
				if (!enumTryParse(method, out this.method)) {
					this.method = RequestMethods.None;
				}
				Path = firstLineMatch.Groups["Path"].ToString();
				Path = Uri.UnescapeDataString(Path);
				Version = firstLineMatch.Groups["Version"].ToString();
			}
		}

		/// <summary>
		/// Disposes the request and the underlying streams.
		/// </summary>
		public void Dispose()
		{
			if (!disposed) {
				if (stream != null) stream.Dispose();
				if (Client != null) Client.Close();
				if (response != null) response.Dispose();
				disposed = true;
			}
		}
		
		RequestInfoDump IDumpable<RequestInfoDump>.Dump()
		{
			return new RequestInfo.RequestInfoDump(this);
		}

		static bool enumTryParse<T>(string strType, out T result)
		{
			string strTypeFixed = strType.Replace(' ', '_');
			if (Enum.IsDefined(typeof(T), strTypeFixed)) {
				result = (T)Enum.Parse(typeof(T), strTypeFixed, true);
				return true;
			} else {
				foreach (string value in Enum.GetNames(typeof(T))) {
					if (value.Equals(strTypeFixed, StringComparison.OrdinalIgnoreCase)) {
						result = (T)Enum.Parse(typeof(T), value);
						return true;
					}
				}
				result = default(T);
				return false;
			}
		}
		
		public class RequestInfoDump
		{
			public RequestInfo RequestInfo { get; private set; }
			public NetworkStream Stream { get { return RequestInfo.stream; } }
			public TextReader Reader { get { return RequestInfo.reader; } }
			public bool Disposed { get { return RequestInfo.disposed; } }
			public String HttpVersion { get { return RequestInfo.httpVersion; } }
			public HeaderBuilder Response { get { return RequestInfo.response; } }
			public SmartDictionary<string, string> Headers { get { return RequestInfo.headers; } }
			
			public RequestInfoDump(RequestInfo info)
			{
				RequestInfo = info;
			}
		}
	}
}
